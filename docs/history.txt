*** TODO ***
* check that it is impossible to call function
  with wrong arguments
* check functions declaration with 
  other code mix. 
* native calls

*** GOOD TODO ***
* try run tests/run.py
* native call
* types check. void -> int

*** WONTDO ***
* bytecode for visit function beginning (signature)
* get bug with function names collision
* assert(false); in the end of each visitor

*** DONE ***
* bind vars from arguments
* type cast assign
* types cast set
* return
* calls is fix
* casts order in mathvm.h
* function arguments cast 
* function call
* basic function call (stumb)
* function agruments

* Arithmetic AND 
* Arithmetic OR 
* Arithmetic XOR 
* while
* while, for => jumps ?
* for
* range
* Unary minus
* if
* unary operations

* assign cast
* types casts for binaryOp (left op)
* ensure with position 
* visitCallNode type
* undefined function call error
* IMUL DMUL bug
* var load
* var context
* print node
* print types
* conversions before assignment
* types stack
* use string constants in code  (Code::_constants)

* just arithmetic bytecode
* bytecode var declaration
* review code 
* use string constants in code  (Code::_constants)
* basic assign
* visit literals
* disassemble with string literals
* TranslatedFunction disassemble
* basic test translator
* print some code
* simple visitor with function names
* folder with examples
* TranslatedFunction
* Mathvm:Bytecode ?
* Mathvm::BytecodeFunction ?
* TranslatedFunction stumb
* Code::disassemble ?
* my code basic imp
* understand Code** usage
* NULL status< parseProgramm
* compile bytecodeTranslator
* get all what done before